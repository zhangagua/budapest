# 从分布式系统中的CAP谈着走...

tags： 分布式系统

---

有的理论不详细深入的思考，仅仅是浮于表面，总归是要出问题的。(-__-)b。
例如某次和童鞋的讨论中，我把分布式系统中的隔离级别和一致性搞混了。场景是这样的：A和B两个机器，A机器的备机为B，AB同时对外提供读服务。A中更新了x的值，还未同步到B时，此刻调皮的C同时读A和B的x值，(-?-)，好的，这个就是一致性问题了。还有个倒霉的D客户端，它在A机器上连着发起一次事务，该事物中去读了两次x，发现这货的值居然不一样，(◎﹏◎)，好的，这个问题就是事务隔离级别的问题了。

懵。

我读书少你不要骗我，为啥我还是觉得这两个问题都是个一致性问题呢。你读出来的数据不一样，那就是不一致的啊。回归本源，隔离级别讲的是__两个事务间的可视性__，而一致性则没这么简单，还得分开说。

在传统的数据库中，既ACID中，C就是一致性，而在分布式系统中，我们也在讲一致性。虽然同样都是一致性，__但是这两个一致性的真正含义是不一样的__。

>ACID中的C：以事务为核心，指的是事务前和事务后，系统的状态是一致的。一个简单的例子，银行账户中A用户从账户中转账10块钱到B的户头（这是一个事务），这个事务不管成功还是失败，A用户和B用户的账户总和都是同一个值，这个，就是ACID中的一致性。
分布式系统中的C：all client always have the same view of the data. 主要强调的是客户端的感受。说白了就是为了可靠性准备的多个副本间数据在客户端看来是否是一致的。

面向的主体都不一样，怎么可能是同一个东西。姑且我们称为第一类一致性和第二类一致性。其实在分布式系统中，我们也会涉及到第一类一致性的，只不过提的少，大部分地方和大多数时候我们在分布式系统中提到的一致性都是后面一类。比如在分布式系统中，我们以actor模式为基础搞了消息中间件，A库中的a账户减去10块，然后封装消息B库中的b账户加10块丢给消息中间件。此时呢，如果但看A库B库，数据库是不一致的，甚至是异常的，但是算上中间件中的消息，系统就是一致的。这里说的一致，就是第一类一致性咯。

好的，写在前面这段话的意思是，有的概念我们天天听，听的都起茧了，但是却并没有真正明白或者说思考过它的内涵，久而久之就模糊了，混淆了。于是我们来进入正题，从CAP谈着走，然后再展开。

# CAP理论

在分布式系统中，一致性（consistency）、可用性（Availability）、分区容错（partition-tolerance）三者不能全部兼顾，只能取其二。这个就叫CAP猜想，是2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出的。之后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式领域的公认定理。
关于CAP理论的不严谨的证明的话，直接用反证法就好了。

这个理论不用多解释，放一张图，大家一下就明白了。

![CAP](/images/cap_theorem.jpg)

需要提醒的是，这里的一致性是第二类一致性（下面如果没有单独说第一类第二类一致性，那么都是指第二类一致性），而且是强一致性。
一般来说，一致性分为三类：强一致性，弱一致性，最终一致性。只要不是强一致性就可以认为是放弃了C。
追求CA的系统，可做到ACID；追求AP，我们称为BASE，BASE是指基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventual Consistency）。

>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。
最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。

ACID是传统数据库常用的设计理念，追求的是强一致性模型。大型分布式系统往往是BASE，提出通过牺牲强一致性获得高可用性。ACID和BASE代表了两种截然相反的设计哲学。
不过在一些系统中，我们可以看到他们的组合。

还有个我们没有提到的问题：分布式事务。这是一个避不开的话题。分布式系统横向扩展，获得数据量上的迅速提升，往往会导致系统的事务可用性降低。所以有的分布式系统干脆不支持事务。说到不支持事务，我想说的是Bigtable似乎存在两种说法，第一种是说Bigtable支持行级别的事务，因为它有行锁；另一个说法是说Bigtable本身不支持事务，是在Chubby的支持下才支持的事务。
[看这里](http://blog.csdn.net/maray/article/details/6769075)
这个锅子是谁？能和我男神杨传辉勾搭上？尼玛，做OceanBase的人说的话可行度还是有的吧！
换个调侃一点的说法，请自行脑补画面：
__你问我Bigtable支持不支持事务，我说是支持的;你问我支持到哪种程度，行级别。OMG__
这个问题是个不开心的过程，不提了，还是接着写。
扯到事务就得说到2PC，这周末要做一个paoxs，raft的报告，到时候把ppt做成图片发到博客里来吧。
再收回聊聊一致性。

# 一致性

一致性的模型上面也说到了，就是大致分为三种，强一致性，弱一致性，最终一致性。

>强一致性：只要操作返回成功，那么任意多个用户读，看到的都是同一个值
弱一致性：操作返回成功后，多个用户读会可能会出现读值失败的情况
最终一致性：操作返回成功后，有可能读出来也可能读不出来，但是过了一个时间窗口之后，他们读到的值都会是一致的

其中，最终一致性还可以细分。(从网上搬过来的哟)

>因果一致性（Casual Consitency）：如果A进程在更新之后向B进程通知更新的完成，那么B的访问操作将会返回更新的值。如果没有因果关系的C进程将会遵循最终一致性的规则。
读己所写一致性（Read your writes）：因果一致性的特定形式。一个进程总可以读到自己更新的数据。
会话一致性（session）：读己所写一致性的特定形式。进程在访问存储系统同一个会话内，系统保证该进程读己之所写。
单调读一致性（Monotonic Reads）：如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。
单调写一致性（Monotonic Writes）：系统保证对同一个进程的写操作串行化。
读后写（Writes follow reads）：顾名思义了，也就是在读操作后面的写操作要是基于至少跟上一次读出来一样新的值。也就是如果进程在地点1读了x，那么在地点2要写x的副本的话，至少写的时候应该是基于至少和地点1读出的一样新的值。

然后这里再贴张图：
![Eventually Consistent](/images/family_tree.jpg)

第一次见这张图是在[这里](http://chuansong.me/n/2035165)。我觉得有意思的是真的把一致性和隔离级别放到一起了，哪些一致性可以做到哪种隔离，比较有意思。