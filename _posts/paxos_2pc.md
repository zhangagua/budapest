---
title: 再议paxos及其应用
date: 2016-08-15 22:06:14
tags: 分布式系统
categories: 分布式一致性算法
---


前面一篇《戏说paxos》实在是粗陋浅显的理了一下paxos算法在《paxos made simple》的逻辑证明顺序。在当时我真的只是了解了paxos这个算法在干什么。但是这个算法具有不可中止性，它只会选出一个永久不变的值，它究竟该如何在应用中大展身手呢？我知道Spanner有个paxos group的概念，Chubby也是使用了paxos，但是真的具体到怎么用，真的比较茫然。

前段时间看到了微信后台团队在phxpaxos开源库在github上出现了，然后追着找到他们的微信公众号中对这个东西的介绍。读完以后，真的，所有对paxos应用级别的疑惑一下子全部都没有了！一个崭新的，清晰的paxos算法深深的刻入的脑海里面。
我从一开始给自己定下的原则是：我的博客必须全部原创。
可是当我面对别人已经嚼碎的知识的时候，真有一刻动摇了。不过知识是可以拓展和延伸的。所以我这篇想做的事情就是，以该文章为基础，拓展和延伸，既然它是深入的，那么我就拓展它的宽度。
先把该开源项目和文章放在前面，以示尊重。
[github地址](https://github.com/tencent-wechat/phxpaxos)
[微信自研生产级paxos类库PhxPaxos实现原理介绍](http://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&mid=2247483695&idx=1&sn=91ea422913fc62579e020e941d1d059e&scene=0&utm_source=tuicool&utm_medium=referral)

# 两阶段提交

TiDB的创始人黄老师说了，分布式事务只有一种解决方案：2PC。我再议一次2PC。2PC是与paxos有渊源的，放在最后说。
我自己今天做了PPT的讲解，所以就直接贴ppt中的图片了。

![2pc_1](/images/paxos_2pc/2pc1.jpg)
![2pc_2](/images/paxos_2pc/2pc2.jpg)
![2pc_3](/images/paxos_2pc/2pc3.jpg)

从[这里](http://coolshell.cn/articles/10910.html)引出一段话来说2PC的问题：
> 
 1. 如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。
 2. 如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。
 3. 糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。
 
 ![3pc_1](/images/paxos_2pc/3pc1.jpg)
 
 3PC一般很少使用，虽然解决了2PC的问题，不过状态更多了说明异常情况更多了。
 
# paxos工业级应用

paxos用来干嘛的？
确定一个值！

如下图，有三台机器（后面为了简化问题，不做特别说明都是以三台机器作为讲解例子），每台机器上运行这Acceptor来遵守paxos协议，每台机器的Acceptor为自己的一份Data数据服务，可以有任意多个Proposer(简单理解为客户端就可以了)。当paxos协议宣称一个值被确定（Chosen）后，那么Data数据就会被确定，并且永远不会被改变。
![paxos三机模型](/images/paxos_2pc/paxos_1.jpg)

确定一个值，而且就永久不变的值，那么这个东西的价值不大。
如果可以做到有序的确定多个值，那么其功能就有很大的想象空间了。

我们假设走一次paxos算法状态机（既开始确定一个值到确定好这个值），称为一个实例（instance）。

>首先给实例一个编号，定义为i，i从0开始，只增不减，由本机器生成，不依赖网络。
其次，我们保证一台机器任一时刻只能有一个实例在工作，这时候Proposer往该机器的写请求都会被当前工作的实例受理。
最后，当编号为i的实例获知已经确定好一个值之后，这个实例将会被销毁，进而产生一个编号为i+1的实例。
 
![paxos多实例模型](/images/paxos_2pc/paxos_2.jpg)
 
我们假设我们要实现一个K-V系统，我们在具体到上图中一台机器上，看看他多次走paxos协议都干了什么。
 
![paxos串行实现多个值](/images/paxos_2pc/paxos_3.jpg)
 
我是抽重点讲的，所以还是强烈建议去原文看看，特别是paxos在工程中的优化是非常重要的，不然会有多次网络和磁盘操作。

# Spanner中的paxos和2pc

Spanner中，也有paxos group的概念，每个group通过paxos算法来保证一致性。
同时每个group还会利用paxos选出一个leader来。

一次分布式事务，会涉及到多个paxos group，这些paxos group的leader会一起通过paxos选出一个coordinator leader，然后让协调领导来当2pc算法的协调者，分布式事务通过2pc来做。

# Paxos和2pc

![paxos多实例模型](/images/paxos_2pc/paxos_4.jpg)
	 
从这张图能看出来，其实它是不是长得也像一个“两阶段提交”提交，只不过游戏规则变化了。
所以有人说paxos是两阶段提交的优化，这样的说法也是不无道理的。
至于到底用选用哪种算法还是只能是看需求了。
